<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Справочник</title>
  <link rel="stylesheet" href="../css/project-test.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200&display=swap" rel="stylesheet">
  <link href="../css/prism.css" rel="stylesheet">
  <script src="../js/prism.js"></script>
  <script src="../js/project.js"></script>
</head>

<body>
  <div class="main-wrapper">
    <main id="content" class="main_content" role="main">
      <article class="main-page-content" lang="ru"> <!-- lang="ru не совсем понял для чего-->
        <section aria-labelledby="Пошаговое выполнение скрипта">
              <h2 id="Пошаговое выполнение скрипта">Пошаговое выполнение скрипта</h2>
              <div class="section-content">
                <p>А теперь давайте пошагаем по нашему скрипту.</p>
                <p>Для этого есть кнопки в верхней части правой панели. Давайте рассмотрим их.</p>
                <dl>
                  <dt>
                    <p><span class="devtools" style="background-position:-146px -168px"></span> <strong>– «Resume»:
                        продолжить выполнение, быстрая клавиша <kbd>F8</kbd>.</strong></p>
                  </dt>
                  <dd>
                    <p>Возобновляет выполнение кода. Если больше нет точек останова, то выполнение просто продолжается,
                      без контроля отладчиком.</p>
                    <p>Вот, что мы увидим, кликнув на неё:</p>
                    <img src="../svg/chrome-sources-debugger-trace-1.svg">
                    <p>Выполнение кода возобновилось, дошло до другой точки останова внутри <code>say()</code>, и
                      отладчик
                      снова приостановил выполнение. Обратите внимание на пункт «Call stack» справа: в списке появился
                      ещё
                      один вызов. Сейчас мы внутри <code>say()</code>.</p>
                  </dd>

                  <dt><span class="devtools" style="background-position:-200px -190px"></span><strong>– «Step»:
                      выполнить
                      следующую команду, быстрая клавиша <kbd>F9</kbd>.</strong></dt>
                  <dd>
                    <p>Выполняет следующую инструкцию. Если мы нажмём на неё сейчас, появится <code>alert</code>.</p>
                    <p>Нажатие на эту кнопку снова и снова приведёт к пошаговому выполнению всех инструкций скрипта
                      одного
                      за другим.</p>
                  </dd>

                  <dt><span class="devtools" style="background-position:-62px -192px"></span><strong>– «Step over»:
                      выполнить следующую команду, но не заходя внутрь функции, быстрая клавиша <kbd>F10</kbd>.</strong>
                  </dt>
                  <dd>
                    <p>Работает аналогично предыдущей команде «Step», но ведёт себя по-другому, если следующая
                      инструкция
                      является вызовом функции (имеется ввиду: не встроенная, как <code>alert</code>, а объявленная нами
                      функция).</p>
                    <p>Если сравнить, то команда «Step» переходит во вложенный вызов функцию и приостанавливает
                      выполнение
                      в первой строке, в то время как «Step over» выполняет вызов вложенной функции незаметно для нас,
                      пропуская её внутренний код.</p>
                    <p>Затем выполнение приостанавливается сразу после вызова функции.</p>
                    <p>Это хорошо, если нам не интересно видеть, что происходит внутри вызова функции.</p>
                  </dd>

                  <dt><span class="devtools" style="background-position:-4px -194px"></span><strong>– «Step into»,
                      быстрая
                      клавиша <kbd>F11</kbd>.</strong></dt>
                  <dd>
                    <p>Это похоже на «Step», но ведёт себя по-другому в случае асинхронных вызовов функций. Если вы
                      только
                      начинаете изучать JavaScript, то можете не обращать внимания на разницу, так как у нас ещё нет
                      асинхронных вызовов.</p>
                    <p>На будущее просто помните, что команда «Step» игнорирует асинхронные действия, такие как
                      <code>setTimeout</code> (вызов функции по расписанию), которые выполняются позже. «Step into»
                      входит
                      в их код, ожидая их, если это необходимо. См. <a
                        href="https://developer.chrome.com/blog/new-in-devtools-65/#async">DevTools manual</a> для
                      получения более подробной информации.
                    </p>
                  </dd>

                  <dt><span class="devtools" style="background-position:-32px -194px"></span><strong>– «Step out»:
                      продолжить выполнение до завершения текущей функции, быстрая клавиша
                      <kbd>Shift+F11</kbd>.</strong>
                  </dt>
                  <dd>
                    <p>Продолжает выполнение и останавливает его в самой последней строке текущей функции. Это удобно,
                      когда мы случайно вошли во вложенный вызов, используя <span class="devtools"
                        style="background-position:-200px -190px"></span>, но это нас не интересует, и мы хотим
                      продолжить
                      его до конца как можно скорее.</p>
                  </dd>

                  <dt><span class="devtools" style="background-position:-61px -74px"></span><strong>–
                      активировать/деактивировать все точки останова(breakpoints).</strong></dt>
                  <dd>
                    <p>Эта кнопка не влияет на выполнение кода, она лишь позволяет массово включить/отключить точки
                      останова.</p>
                  </dd>

                  <dt><span class="devtools" style="background-position:-90px -146px"></span><strong>–
                      включить/отключить
                      автоматическую паузу в случае ошибки.</strong></dt>
                  <dd>
                    <p>При включении, если открыты инструменты разработчика, ошибка при выполнении скрипта автоматически
                      приостанавливает его. Затем мы можем проанализировать переменные в отладчике, чтобы понять, что
                      пошло не так. Поэтому, если наш скрипт умирает с ошибкой, мы можем открыть отладчик, включить эту
                      опцию и перезагрузить страницу, чтобы увидеть, где он умирает и каков контекст в этот момент.</p>
                  </dd>
                </dl>
                <div class="note notecard" id="transparent-js">
                  <div class="important_type">Continue to here</div>
                  <p>Щелчок правой кнопкой мыши по строке кода открывает контекстное меню с отличной опцией под
                    названием
                    «Continue to here» («продолжить до этого места»).</p>
                  <p>Это удобно, когда мы хотим перейти на несколько шагов вперёд к строке, но лень устанавливать точку
                    останова (breakpoint).</p>
                </div>
              </div>
            </section>
      </article>
    </main>
  </div>
</body>
