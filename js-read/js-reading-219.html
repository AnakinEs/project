<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Справочник</title>
  <link rel="stylesheet" href="../css/project-test.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200&display=swap" rel="stylesheet">
  <link href="../css/prism.css" rel="stylesheet">
  <script src="../js/prism.js"></script>
  <script src="../js/project.js"></script>
</head>

<body>
  <div class="main-wrapper">
    <main id="content" class="main_content" role="main">
      <article class="main-page-content" lang="ru"> <!-- lang="ru не совсем понял для чего-->
<section aria-labelledby='Объясните значение "this"'>
                <h3 id='Объясните значение "this"'>Объясните значение "this"</h3>
                <div class="section-content">
                  <p>В представленном ниже коде мы намерены вызвать <code>obj.go()</code> метод 4 раза подряд.</p>
                  <p>Но вызовы <code>(1)</code> и <code>(2)</code> работают иначе, чем <code>(3)</code> и
                    <code>(4)</code>. Почему?
                  </p>
                  <pre><code class="language-js">let obj, method;

obj = {
  go: function() { alert(this); }
};

obj.go();               // (1) [object Object]

(obj.go)();             // (2) [object Object]

(method = obj.go)();    // (3) undefined

(obj.go || obj.stop)(); // (4) undefined</code></pre>
                  <details>
                    <summary class="solution">
                      <li class="task__solution" type="button">решение</li>
                    </summary>
                    <div>
                      <p>Вот как это объясняется.</p>
                      <ol>
                        <li>
                          <p>Это обычный вызов метода объекта через точку <code>.</code>, и <code>this</code> ссылается
                            на
                            объект перед точкой.</p>
                        </li>
                        <li>
                          <p>Здесь то же самое. Круглые скобки (оператор группировки) тут не изменяют порядок выполнения
                            операций – доступ к методу через точку в любом случае срабатывает первым.</p>
                        </li>
                        <li>
                          <p>Здесь мы имеем более сложный вызов <code>(expression).method()</code>. Такой вызов
                            работает,
                            как если бы он был разделён на 2 строчки:</p>
                          <pre><code class="language-js">f = obj.go; // вычисляется выражение (переменная f ссылается на код функции)
f();        // вызов функции, на которую ссылается f</code></pre>
                          <p>Здесь <code>f()</code> выполняется как функция, без передачи значения <code>this</code>.
                          </p>
                        </li>
                        <li>
                          <p>Тут похожая ситуация на случай <code>(3)</code> – идёт потеря значения <code>this</code>.
                          </p>
                        </li>
                      </ol>
                      <p>Чтобы объяснить поведение в примерах <code>(3)</code> и <code>(4)</code>, нам нужно помнить,
                        что
                        доступ к свойству (через точку или квадратные скобки) возвращает специальное значение ссылочного
                        типа (Reference Type).</p>
                      <p>За исключением вызова метода, любая другая операция (подобно операции присваивания
                        <code>=</code>
                        или сравнения через логические операторы, например <code>||</code>) превращает это значение в
                        обычное, которое не несёт информации, позволяющей установить <code>this</code>.
                      </p>
                    </div>
                  </details>
                </div>
              </section>
      </article>
    </main>
  </div>
  <script>
    function show(param) {
      if ((event.target.parentElement.tagName == "PRE") && (event.target.parentElement.nextElementSibling.tagName == "IFRAME")) {
        event.target.parentElement.nextElementSibling.remove();
        event.target.parentElement.insertAdjacentHTML('afterend', param);
        event.target.blur();
      } else if ((event.target.parentElement.tagName == "PRE") && !(event.target.parentElement.nextElementSibling.tagName == "IFRAME")) {
        event.target.parentElement.insertAdjacentHTML('afterend', param);
        event.target.blur();
      }
    }
  </script>

  <script>
    content.onclick = function (event) {
      if (event.target.className != 'task__solution') return;
      let decisionDiv = event.target.closest('.decision_div');
      // let decisionDiv = document.querySelector('.decision_div');
      let decisionContent = decisionDiv.querySelector('.decision_content');
      decisionContent.classList.toggle('open');
    }
  </script>
</body>

