<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Справочник</title>
  <link rel="stylesheet" href="../css/project-test.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200&display=swap" rel="stylesheet">
  <link href="../css/prism.css" rel="stylesheet">
  <script src="../js/prism.js"></script>
  <script src="../js/project.js"></script>
</head>

<body>
  <div class="main-wrapper">
    <main id="content" class="main_content" role="main">
      <article class="main-page-content" lang="ru"> <!-- lang="ru не совсем понял для чего-->
        <section aria-labelledby="Сравнение с null и undefined">
          <h2 id="Сравнение с null и undefined">Сравнение с null и undefined</h2>
          <div class="section-content">
            <p>Поведение <code>null</code> и <code>undefined</code> при сравнении с другими значениями — особое:</p>
            <p><strong>При строгом равенстве <code>===</code></strong></p>
            <p>Эти значения различны, так как различны их типы.</p>
            <pre><code class="language-js">alert( null === undefined ); // false</code></pre>
            <p><strong>При нестрогом равенстве <code>==</code></strong></p>
            <p>Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.</p>
            <pre><code class="language-js">alert( null == undefined ); // true</code></pre>
            <p><strong>При использовании математических операторов и других операторов сравнения
                <code>&lt; &gt; &lt;= &gt;=</code></strong></p>
            <p>Значения <code>null/undefined</code> преобразуются к числам: <code>null</code> становится
              <code>0</code>, а <code>undefined</code> – <code>NaN</code>.
            </p>
            <p>Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила. И, что более важно, как
              избежать ошибок при их использовании.</p>
          </div>
        </section>
        <section aria-labelledby="Странный результат сравнения null и 0">
          <h2 id="Странный результат сравнения null и 0">Странный результат сравнения null и 0</h2>
          <div class="section-content">
            <p>Сравним <code>null</code> с нулём:</p>
            <pre><code class="language-js">alert( null &gt; 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null &gt;= 0 ); // (3) true</code></pre>
            <p>С точки зрения математики это странно. Результат последнего сравнения говорит о том, что
              "<code>null</code> больше или равно нулю", тогда результат одного из сравнений выше должен быть
              <code>true</code>, но они оба ложны.
            </p>
            <p>Причина в том, что нестрогое равенство и сравнения <code>> < >= <=</code> работают по-разному.
              Сравнения преобразуют <code>null</code> в число, рассматривая его как <code>0</code>. Поэтому
              выражение
              (3) <code>null >= 0</code> истинно, а <code>null > 0</code> ложно.</p>
            <p>С другой стороны, для нестрогого равенства <code>==</code> значений <code>undefined</code> и
              <code>null</code> действует особое правило: эти значения ни к чему не приводятся, они равны друг другу
              и
              не равны ничему другому. Поэтому (2) <code>null == 0</code> ложно.
            </p>
          </div>
        </section>
        <section aria-labelledby="Несравненное значение undefined">
          <h2 id="Несравненное значение undefined">Несравненное значение undefined</h2>
          <div class="section-content">
            <p>Значение <code>undefined</code> несравнимо с другими значениями:</p>
            <pre><code class="language-js">alert( undefined &gt; 0 ); // false (1)
alert( undefined &lt; 0 ); // false (2)
alert( undefined == 0 ); // false (3)</code></pre>
            <p>Почему же сравнение <code>undefined</code> с нулём всегда ложно?</p>
            <p>На это есть следующие причины:</p>
            <ul>
              <li>Сравнения <code>(1)</code> и <code>(2)</code> возвращают <code>false</code>, потому что
                <code>undefined</code> преобразуется в <code>NaN</code>, а <code>NaN</code> – это специальное
                числовое
                значение, которое возвращает <code>false</code> при любых сравнениях.
              </li>
              <li>Нестрогое равенство <code>(3)</code> возвращает <code>false</code>, потому что
                <code>undefined</code> равно только <code>null</code>, <code>undefined</code> и ничему больше.
              </li>
            </ul>
          </div>
        </section>
        <section aria-labelledby="Как избежать проблем">
          <h2 id="Как избежать проблем">Как избежать проблем</h2>
          <div class="section-content">
            <p>Зачем мы рассмотрели все эти примеры? Должны ли мы постоянно помнить обо всех этих особенностях? Не
              обязательно. Со временем все они станут вам знакомы, но можно избежать проблем, если следовать
              надёжным
              правилам:</p>
            <ul>
              <li>Относитесь очень осторожно к любому сравнению с <code>undefined/null</code>, кроме случаев
                строгого
                равенства <code>===</code>.</li>
              <li>Не используйте сравнения <code>&gt;= &gt; &lt; &lt;=</code> с переменными, которые могут принимать
                значения <code>null/undefined</code>, разве что вы полностью уверены в том, что делаете. Если
                переменная может принимать эти значения, то добавьте для них отдельные проверки.</li>
            </ul>
          </div>
        </section>
      </article>
    </main>
  </div>
</body>
